{"docs":[{"location":"paradox.json","text":"","title":""},{"location":"index.html","text":"","title":"JWT Scala"},{"location":"index.html#jwt-scala","text":"Scala support for JSON Web Token (JWT). Supports Java 8+, Scala 2.12, Scala 2.13 and Scala 3 (for json libraries that support it). Dependency free. Optional helpers for Play Framework, Play JSON, Json4s Native, Json4s Jackson, Circe, uPickle and Argonaut.","title":"JWT Scala"},{"location":"index.html#usage","text":"JWT Scala is divided in several sub-projects each targeting a specific JSON library, check the doc from the menu for installation and usage instructions.","title":"Usage"},{"location":"index.html#algorithms","text":"If you are using String key, please keep in mind that such keys need to be parsed. Rather than implementing a super complex parser, the one in JWT Scala is pretty simple and might not work for all use-cases (especially for ECDSA keys). In such case, consider using SecretKey or PrivateKey or PublicKey directly. It is way better for you. All API support all those types.\nCheck ECDSA samples for more infos.\nName Description HMD5 HMAC using MD5 algorithm HS224 HMAC using SHA-224 algorithm HS256 HMAC using SHA-256 algorithm HS384 HMAC using SHA-384 algorithm HS512 HMAC using SHA-512 algorithm RS256 RSASSA using SHA-256 algorithm RS384 RSASSA using SHA-384 algorithm RS512 RSASSA using SHA-512 algorithm ES256 ECDSA using SHA-256 algorithm ES384 ECDSA using SHA-384 algorithm ES512 ECDSA using SHA-512 algorithm EdDSA EdDSA signature algorithms","title":"Algorithms"},{"location":"index.html#security-concerns","text":"This lib doesn’t want to impose anything, that’s why, by default, a JWT claim is totally empty. That said, you should always add an issuedAt attribute to it, probably using claim.issuedNow. The reason is that even HTTPS isn’t perfect and having always the same chunk of data transfered can be of a big help to crack it. Generating a slightly different token at each request is way better even if it adds a bit of payload to the response. If you are using a session timeout through the expiration attribute which is extended at each request, that’s fine too. I can’t find the article I read about that vulnerability but if someone has some resources about the topic, I would be glad to link them.","title":"Security concerns"},{"location":"index.html#license","text":"This software is licensed under the Apache 2 license, quoted below.\nCopyright 2021 JWT-Scala Contributors.\nLicensed under the Apache License, Version 2.0 (the “License”); you may not use this project except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on an “AS IS” BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"jwt-core/index.html","text":"This module doesn’t use any dependency, it is useful if you don’t have any Json library in your project.\nIt is based a naive parsing of Json strings, and doesn’t support any custom parameter in the Claim so if you need any custom parameter, or if you’re already using one of the supported Json libraries, consider using that instead.","title":"Native"},{"location":"jwt-core/index.html#native","text":"API Documentation\nlibraryDependencies += \"com.github.jwt-scala\" %% \"jwt-core\" % \"11.0.3\"","title":"Native"},{"location":"jwt-core/index.html#basic-usage","text":"import java.time.Clock\nimport pdi.jwt.{Jwt, JwtAlgorithm, JwtHeader, JwtClaim, JwtOptions}\nimplicit val clock: Clock = Clock.systemUTC\nval token = Jwt.encode(\"\"\"{\"user\":1}\"\"\", \"secretKey\", JwtAlgorithm.HS256)\nJwt.decodeRawAll(token, \"secretKey\", Seq(JwtAlgorithm.HS256))\nJwt.decodeRawAll(token, \"wrongKey\", Seq(JwtAlgorithm.HS256))","title":"Basic usage"},{"location":"jwt-core/index.html#encoding","text":"// Encode from string, header automatically generated\nJwt.encode(\"\"\"{\"user\":1}\"\"\", \"secretKey\", JwtAlgorithm.HS384)\n\n// Encode from case class, header automatically generated\n// Set that the token has been issued now and expires in 10 seconds\nJwt.encode(JwtClaim({\"\"\"{\"user\":1}\"\"\"}).issuedNow.expiresIn(10), \"secretKey\", JwtAlgorithm.HS512)\n\n// You can encode without signing it\nJwt.encode(\"\"\"{\"user\":1}\"\"\")\n\n// You can specify a string header but also need to specify the algorithm just to be sure\n// This is not really typesafe, so please use it with care\nJwt.encode(\"\"\"{\"typ\":\"JWT\",\"alg\":\"HS256\"}\"\"\", \"\"\"{\"user\":1}\"\"\", \"key\", JwtAlgorithm.HS256)\n\n// If using a case class header, no need to repeat the algorithm\n// This is way better than the previous one\nJwt.encode(JwtHeader(JwtAlgorithm.HS256), JwtClaim(\"\"\"{\"user\":1}\"\"\"), \"key\")","title":"Encoding"},{"location":"jwt-core/index.html#decoding","text":"In JWT Scala, espcially when using raw strings which are not typesafe at all, there are a lot of possible errors. This is why nearly all decode functions will return a Try rather than directly the expected result. In case of failure, the wrapped exception should tell you what went wrong.\nTake note that nearly all decoding methods (including those from helper libs) support either a String key, or a PrivateKey with a Hmac algorithm or a PublicKey with a RSA or ECDSA algorithm.\n// Decode all parts of the token as string\nJwt.decodeRawAll(token, \"secretKey\", JwtAlgorithm.allHmac())\n\n// Decode only the claim as a string\nJwt.decodeRaw(token, \"secretKey\", Seq(JwtAlgorithm.HS256))\n\n// Decode all parts and cast them as a better type if possible.\n// Since the implementation in JWT Core only use string, it is the same as decodeRawAll\n// But check the result in JWT Play JSON to see the difference\nJwt.decodeAll(token, \"secretKey\", Seq(JwtAlgorithm.HS256))\n\n// Same as before, but only the claim\n// (you should start to see a pattern in the naming convention of the functions)\nJwt.decode(token, \"secretKey\", Seq(JwtAlgorithm.HS256))\n\n// Failure because the token is not a token at all\nJwt.decode(\"Hey there!\")\n\n// Failure if not Base64 encoded\nJwt.decode(\"a.b.c\")\n\n// Failure in case we use the wrong key\nJwt.decode(token, \"wrongKey\", Seq(JwtAlgorithm.HS256))\n\n// Failure if the token only starts in 5 seconds\nJwt.decode(Jwt.encode(JwtClaim().startsIn(5)))","title":"Decoding"},{"location":"jwt-core/index.html#validating","text":"If you only want to check if a token is valid without decoding it. You have two options: validate functions that will throw the exceptions we saw in the decoding section, so you know what went wrong, or isValid functions that will return a boolean in case you don’t care about the actual error and don’t want to bother with catching exception.\n// All good\nJwt.validate(token, \"secretKey\", Seq(JwtAlgorithm.HS256))\nJwt.isValid(token, \"secretKey\", Seq(JwtAlgorithm.HS256))\n\n// Wrong key here\nJwt.validate(token, \"wrongKey\", Seq(JwtAlgorithm.HS256))\nJwt.isValid(token, \"wrongKey\", Seq(JwtAlgorithm.HS256))\n\n// No key for unsigned token => ok\nJwt.validate(Jwt.encode(\"{}\"))\nJwt.isValid(Jwt.encode(\"{}\"))\n\n// No key while the token is actually signed => wrong\nJwt.validate(token)\nJwt.isValid(token)\n\n// The token hasn't started yet!\nJwt.validate(Jwt.encode(JwtClaim().startsIn(5)))\nJwt.isValid(Jwt.encode(JwtClaim().startsIn(5)))\n\n// This is no token\nJwt.validate(\"a.b.c\")\nJwt.isValid(\"a.b.c\")","title":"Validating"},{"location":"jwt-core/index.html#using-a-custom-clock","text":"For testing, it can sometimes be useful to use a fake clock that will always return a fixed time. It can be done by instanciating Jwt instead of using the object (based on the system clock):\nimport java.time.{Clock, Instant, ZoneId}\n\nval startTime = Clock.fixed(Instant.ofEpochSecond(0), ZoneId.of(\"UTC\"))\nval endTime = Clock.fixed(Instant.ofEpochSecond(5), ZoneId.of(\"UTC\"))\n\nval customJwt = Jwt(endTime)\n\nval claim = JwtClaim().issuedNow(startTime).expiresIn(10)(startTime)\nval encoded = customJwt.encode(claim, \"key\", JwtAlgorithm.HS256)\n\ncustomJwt.decode(encoded, \"key\", JwtAlgorithm.allHmac())","title":"Using a custom clock"},{"location":"jwt-core/index.html#options","text":"All validating and decoding methods support a final optional argument as a JwtOptions which allow you to disable validation checks. This is useful if you need to access data from an expired token for example. You can disable expiration, notBefore and signature checks. Be warned that if you disable the last one, you have no guarantee that the user didn’t change the content of the token.\nval expiredToken = Jwt.encode(JwtClaim().by(\"me\").expiresIn(-1))\n\n// Fail since the token is expired\nJwt.isValid(expiredToken)\nJwt.decode(expiredToken)\n\n// Let's disable expiration check\nJwt.isValid(expiredToken, JwtOptions(expiration = false))\nJwt.decode(expiredToken, JwtOptions(expiration = false))\nYou can also specify a leeway, in seconds, to account for clock skew.\n// Allow 30sec leeway\nJwt.isValid(expiredToken, JwtOptions(leeway = 30))\nJwt.decode(expiredToken, JwtOptions(leeway = 30))","title":"Options"},{"location":"jwt-core/jwt-claim.html","text":"","title":"JwtClaim Class"},{"location":"jwt-core/jwt-claim.html#jwtclaim-class","text":"import java.time.Clock\nimport pdi.jwt.JwtClaim\n\nJwtClaim()\n\nimplicit val clock: Clock = Clock.systemUTC\n\n// Specify the content as JSON string\n// (don't use var in your code if possible, this is just to ease the sample)\nvar claim = JwtClaim(\"\"\"{\"user\":1}\"\"\")\n\n// Append new content\nclaim = claim + \"\"\"{\"key1\":\"value1\"}\"\"\"\nclaim = claim + (\"key2\", true)\nclaim = claim ++ ((\"key3\", 3), (\"key4\", Seq(1, 2)), (\"key5\", (\"key5.1\", \"Subkey\")))\n\n// Stringify as JSON\nclaim.toJson\n\n// Manipulate basic attributes\n// Set the issuer\nclaim = claim.by(\"Me\")\n\n// Set the audience\nclaim = claim.to(\"You\")\n\n// Set the subject\nclaim = claim.about(\"Something\")\n\n// Set the id\nclaim = claim.withId(\"42\")\n\n// Set the expiration\n// In 10 seconds from now\nclaim = claim.expiresIn(5)\n// At a specific timestamp (in seconds)\nclaim.expiresAt(1431520421)\n// Right now! (the token is directly invalid...)\nclaim.expiresNow\n\n// Set the beginning of the token (aka the \"not before\" attribute)\n// 5 seconds ago\nclaim.startsIn(-5)\n// At a specific timestamp (in seconds)\nclaim.startsAt(1431520421)\n// Right now!\nclaim = claim.startsNow\n\n// Set the date when the token was created\n// (you should always use claim.issuedNow, but I let you do otherwise if needed)\n// 5 seconds ago\nclaim.issuedIn(-5)\n// At a specific timestamp (in seconds)\nclaim.issuedAt(1431520421)\n// Right now!\nclaim = claim.issuedNow\n\n// We can test if the claim is valid => testing if the current time is between \"not before\" and \"expiration\"\nclaim.isValid\n\n// Also test the issuer and audience\nclaim.isValid(\"Me\", \"You\")\n\n// Let's stringify the final version\nclaim.toJson","title":"JwtClaim Class"},{"location":"jwt-core/jwt-claim-private.html","text":"","title":"Jwt Reserved Claims and Private Claims"},{"location":"jwt-core/jwt-claim-private.html#jwt-reserved-claims-and-private-claims","text":"A common use-case of Jwt-Scala (and JWT at large) is developing so-called “public” or “private” claims (and or header params). These are functionally no different than “reserved” claims/header params, other than that they have no standard definition and may only be distinguished within your network or niche industry. “issuer”, “subject”, “audience” etc. are all examples of reserved claims, whereas “user” is a fairly common example of a non-reserved claim.\nGiven that there may be many of these public/private claims, rather than parsing them yourself separate from how reserved claims are parsed (see the JwtClaim Class), you can simply compose JwtClaim with your own custom claims that extend from the JwtReservedClaim trait.\nHere is an example where reserved headers, along with a private “user” claim, is used:\nimport pdi.jwt.{Jwt, JwtHeader, JwtClaim, JwtUtils, JwtJson4sParser}\nimport java.time.Clock\n\n// define your network-specific claims, and compose them with the usual reservedClaims\ncase class JwtPrivateClaim(user: Option[String] = None, reservedClaims: JwtClaim = JwtClaim()) {\n  // merge your json definition along with the reserved claims too\n  def toJson: String = JwtUtils.mergeJson(JwtUtils.hashToJson(Seq(\n      \"user\" -> user,\n    ).collect {\n      case (key, Some(value)) => (key -> value)\n    }), reservedClaims.toJson)\n}\n\n// create a parser with claim type set to the one you just defined\n// notice that the default `JwtHeader` class was used since we're only interested in overriding with a custom private claims type in this example\nobject JwtJson4sPrivate extends JwtJson4sParser[JwtHeader, JwtPrivateClaim] {\n  override implicit val clock = Clock.systemUTC\n\n  override protected def parseClaim(claim: String): JwtPrivateClaim = {\n    val claimJson = super.parse(claim)\n    val jwtReservedClaim: JwtClaim = super.readClaim(claimJson)\n    val content = super.parse(jwtReservedClaim.content)\n    JwtPrivateClaim(super.extractString(content, \"user\"), jwtReservedClaim.withContent(\"{}\"))\n  }\n\n  // here is the only boilerplate (but if you chose to also specify a custom header type then you would make use of this)\n  override protected def parseHeader(header: String): JwtHeader = super.readHeader(parse(header))\n\n  // marginal boilerplate to ensure consistency with isValid checks now that your nesting reserved claims into your custom private claims\n  override protected def extractExpiration(claim: JwtPrivateClaim): Option[Long] = claim.reservedClaims.expiration\n  override protected def extractNotBefore(claim: JwtPrivateClaim): Option[Long] = claim.reservedClaims.notBefore\n}\nYou can then use the same decodeAll method as you would before, now with your fully objectified claims:\nimport scala.util.Try\n// this example chose to use JwtJson4s, but any Json implementation would work the same\nval token: String = Jwt.encode(\"\"\"{\"user\":\"someone\", \"iss\": \"me\"}\"\"\");\nval decoded: Try[(JwtHeader, JwtPrivateClaim, String)] = JwtJson4sPrivate.decodeAll(token)","title":"Jwt Reserved Claims and Private Claims"},{"location":"jwt-core/jwt-header.html","text":"","title":"JwtHeader Case Class"},{"location":"jwt-core/jwt-header.html#jwtheader-case-class","text":"import pdi.jwt.{JwtHeader, JwtAlgorithm}\n\nJwtHeader()\nJwtHeader(JwtAlgorithm.HS256)\nJwtHeader(JwtAlgorithm.HS256, \"JWT\")\n\n// You can stringify it to JSON\nJwtHeader(JwtAlgorithm.HS256, \"JWT\").toJson\n\n// You can assign the default type (but it would have be done automatically anyway)\nJwtHeader(JwtAlgorithm.HS256).withType","title":"JwtHeader Case Class"},{"location":"jwt-core/jwt-ecdsa.html","text":"","title":"Jwt with ECDSA algorithms"},{"location":"jwt-core/jwt-ecdsa.html#jwt-with-ecdsa-algorithms","text":"","title":"Jwt with ECDSA algorithms"},{"location":"jwt-core/jwt-ecdsa.html#with-generated-keys","text":"","title":"With generated keys"},{"location":"jwt-core/jwt-ecdsa.html#generation","text":"import org.bouncycastle.jce.provider.BouncyCastleProvider\nimport java.security.spec.{ECPrivateKeySpec, ECPublicKeySpec, ECGenParameterSpec, ECParameterSpec, ECPoint}\nimport java.security.{SecureRandom, KeyFactory, KeyPairGenerator, Security}\nimport pdi.jwt.{Jwt, JwtAlgorithm}\n// We specify the curve we want to use\nval ecGenSpec = new ECGenParameterSpec(\"P-521\")\n// We are going to use a ECDSA algorithm\n// and the Bouncy Castle provider\nif (Security.getProvider(\"BC\") == null) {\n  Security.addProvider(new BouncyCastleProvider())\n}\nval generatorEC = KeyPairGenerator.getInstance(\"ECDSA\", \"BC\")\ngeneratorEC.initialize(ecGenSpec, new SecureRandom())\n// Generate a pair of keys, one private for encoding\n// and one public for decoding\nval ecKey = generatorEC.generateKeyPair()","title":"Generation"},{"location":"jwt-core/jwt-ecdsa.html#usage","text":"val token = Jwt.encode(\"\"\"{\"user\":1}\"\"\", ecKey.getPrivate, JwtAlgorithm.ES512)\n\nJwt.decode(token, ecKey.getPublic, JwtAlgorithm.allECDSA)","title":"Usage"},{"location":"jwt-core/jwt-ecdsa.html#with-saved-keys","text":"Let’s say you already have your keys, it means you know the S param for the private key and both (X, Y) for the public key. So we will first recreate the keys from those params and then use them just as we did for the previously generated keys.","title":"With saved keys"},{"location":"jwt-core/jwt-ecdsa.html#creation","text":"import org.bouncycastle.jce.ECNamedCurveTable\nimport org.bouncycastle.jce.spec.ECNamedCurveSpec\n\n// Our saved params\nval S = BigInt(\"1ed498eedf499e5dd12b1ab94ee03d1a722eaca3ed890630c8b25f1015dd4ec5630a02ddb603f3248a3b87c88637e147ecc7a6e2a1c2f9ff1103be74e5d42def37d\", 16)\nval X = BigInt(\"16528ac15dc4c8e0559fad628ac3ffbf5c7cfefe12d50a97c7d088cc10b408d4ab03ac0d543bde862699a74925c1f2fe7c247c00fddc1442099dfa0671fc032e10a\", 16)\nval Y = BigInt(\"b7f22b3c1322beef766cadd1a5f0363840195b7be10d9a518802d8d528e03bc164c9588c5e63f1473d05195510676008b6808508539367d2893e1aa4b7cb9f9dab\", 16)\n\n// Here we are using the P-521 curve but you need to change it\n// to your own curve\nval curveParams = ECNamedCurveTable.getParameterSpec(\"P-521\")\nval curveSpec: ECParameterSpec = new ECNamedCurveSpec( \"P-521\", curveParams.getCurve(), curveParams.getG(), curveParams.getN(), curveParams.getH());\n\nval privateSpec = new ECPrivateKeySpec(S.underlying(), curveSpec)\nval publicSpec = new ECPublicKeySpec(new ECPoint(X.underlying(), Y.underlying()), curveSpec)\n\nval privateKeyEC = KeyFactory.getInstance(\"ECDSA\", \"BC\").generatePrivate(privateSpec)\nval publicKeyEC = KeyFactory.getInstance(\"ECDSA\", \"BC\").generatePublic(publicSpec)","title":"Creation"},{"location":"jwt-core/jwt-ecdsa.html#usage","text":"val token = Jwt.encode(\"\"\"{\"user\":1}\"\"\", privateKeyEC, JwtAlgorithm.ES512)\n\nJwt.decode(token, publicKeyEC, Seq(JwtAlgorithm.ES512))\n\n// Wrong key...\nJwt.decode(token, ecKey.getPublic, Seq(JwtAlgorithm.ES512))","title":"Usage"},{"location":"jwt-argonaut.html","text":"","title":"Argonaut"},{"location":"jwt-argonaut.html#argonaut","text":"API Documentation\nlibraryDependencies += \"com.github.jwt-scala\" %% \"jwt-argonaut\" % \"11.0.3\"","title":"Argonaut"},{"location":"jwt-argonaut.html#basic-usage","text":"copysourceimport java.time.Instant\nimport scala.util.Try\n\nimport argonaut.Json\nimport pdi.jwt.{JwtAlgorithm, JwtArgonaut, JwtClaim}\n\nval claim = JwtClaim(\n  expiration = Some(Instant.now().plusSeconds(157784760).getEpochSecond),\n  issuedAt = Some(Instant.now.getEpochSecond)\n)\n\nval key = \"secretKey\"\nval alg = JwtAlgorithm.HS512\n\nval token = JwtArgonaut.encode(claim, key, alg)\nval decodedJson: Try[Json] = JwtArgonaut.decodeJson(token, key, Seq(alg))\nval decodedClaim: Try[JwtClaim] = JwtArgonaut.decode(token, key, Seq(alg))","title":"Basic usage"},{"location":"jwt-argonaut.html#encoding","text":"copysourceimport java.time.Instant\n\nimport argonaut.Parse\nimport pdi.jwt.{JwtAlgorithm, JwtArgonaut}\n\nval key = \"secretKey\"\nval alg = JwtAlgorithm.HS512\n\nval jsonClaim = Parse.parseOption(s\"\"\"{\"expires\":${Instant.now().getEpochSecond}}\"\"\").get\nval jsonHeader = Parse.parseOption(\"\"\"{\"typ\":\"JWT\",\"alg\":\"HS512\"}\"\"\").get\n\nval token1: String = JwtArgonaut.encode(jsonClaim)\nval token2: String = JwtArgonaut.encode(jsonClaim, key, alg)\nval token3: String = JwtArgonaut.encode(jsonHeader, jsonClaim, key)","title":"Encoding"},{"location":"jwt-argonaut.html#decoding","text":"copysourceimport scala.util.Try\n\nimport argonaut.Json\nimport pdi.jwt.{JwtAlgorithm, JwtArgonaut, JwtClaim, JwtHeader}\n\nval claim = JwtClaim(\n  expiration = Some(Instant.now.plusSeconds(157784760).getEpochSecond),\n  issuedAt = Some(Instant.now.getEpochSecond)\n)\nval key = \"secretKey\"\nval alg = JwtAlgorithm.HS512\n\nval token = JwtArgonaut.encode(claim, key, alg)\n\nval decodedJsonClaim: Try[Json] = JwtArgonaut.decodeJson(token, key, Seq(alg))\nval decodedJson: Try[(Json, Json, String)] = JwtArgonaut.decodeJsonAll(token, key, Seq(alg))\n\nval decodedClaim: Try[JwtClaim] = JwtArgonaut.decode(token, key, Seq(alg))\nval decodedToken: Try[(JwtHeader, JwtClaim, String)] = JwtArgonaut.decodeAll(token, key, Seq(alg))","title":"Decoding"},{"location":"jwt-circe.html","text":"","title":"Circe"},{"location":"jwt-circe.html#circe","text":"API Documentation\nlibraryDependencies += \"com.github.jwt-scala\" %% \"jwt-circe\" % \"11.0.3\"","title":"Circe"},{"location":"jwt-circe.html#basic-usage","text":"copysourceimport java.time.Instant\n\nimport pdi.jwt.{JwtAlgorithm, JwtCirce, JwtClaim}\n\nval claim = JwtClaim(\n  expiration = Some(Instant.now.plusSeconds(157784760).getEpochSecond),\n  issuedAt = Some(Instant.now.getEpochSecond)\n)\nval key = \"secretKey\"\nval algo = JwtAlgorithm.HS256\n\nval token = JwtCirce.encode(claim, key, algo)\n\nJwtCirce.decodeJson(token, key, Seq(JwtAlgorithm.HS256))\nJwtCirce.decode(token, key, Seq(JwtAlgorithm.HS256))","title":"Basic usage"},{"location":"jwt-circe.html#encoding","text":"copysourceimport java.time.Instant\n\nimport io.circe._\nimport jawn.{parse => jawnParse}\nimport pdi.jwt.{JwtAlgorithm, JwtCirce}\n\nval key = \"secretKey\"\nval algo = JwtAlgorithm.HS256\n\nval Right(claimJson) = jawnParse(s\"\"\"{\"expires\":${Instant.now.getEpochSecond}}\"\"\")\nval Right(header) = jawnParse(\"\"\"{\"typ\":\"JWT\",\"alg\":\"HS256\"}\"\"\")\n// From just the claim to all possible attributes\nJwtCirce.encode(claimJson)\nJwtCirce.encode(claimJson, key, algo)\nJwtCirce.encode(header, claimJson, key)","title":"Encoding"},{"location":"jwt-circe.html#decoding","text":"copysourceimport java.time.Instant\n\nimport pdi.jwt.{JwtAlgorithm, JwtCirce, JwtClaim}\n\nval claim = JwtClaim(\n  expiration = Some(Instant.now.plusSeconds(157784760).getEpochSecond),\n  issuedAt = Some(Instant.now.getEpochSecond)\n)\nval key = \"secretKey\"\nval algo = JwtAlgorithm.HS256\n\nval token = JwtCirce.encode(claim, key, algo)\n\n// You can decode to JsObject\nJwtCirce.decodeJson(token, key, Seq(JwtAlgorithm.HS256))\nJwtCirce.decodeJsonAll(token, key, Seq(JwtAlgorithm.HS256))\n// Or to case classes\nJwtCirce.decode(token, key, Seq(JwtAlgorithm.HS256))\nJwtCirce.decodeAll(token, key, Seq(JwtAlgorithm.HS256))","title":"Decoding"},{"location":"jwt-json4s.html","text":"","title":"Json4s"},{"location":"jwt-json4s.html#json4s","text":"API Documentation\nlibraryDependencies += \"com.github.jwt-scala\" %% \"jwt-json4s\" % \"11.0.3\"","title":"Json4s"},{"location":"jwt-json4s.html#basic-usage","text":"copysourceimport org.json4s.JsonDSL.WithBigDecimal._\nimport org.json4s._\nimport pdi.jwt.{JwtAlgorithm, JwtJson4s}\n\nval claim = JObject((\"user\", 1), (\"nbf\", 1431520421))\nval key = \"secretKey\"\nval algo = JwtAlgorithm.HS256\n\nJwtJson4s.encode(claim)\n\nval token = JwtJson4s.encode(claim, key, algo)\n\nJwtJson4s.decodeJson(token, key, Seq(JwtAlgorithm.HS256))\n\nJwtJson4s.decode(token, key, Seq(JwtAlgorithm.HS256))","title":"Basic usage"},{"location":"jwt-json4s.html#encoding","text":"copysourceval header = JObject((\"typ\", \"JWT\"), (\"alg\", \"HS256\"))\n\nJwtJson4s.encode(claim)\nJwtJson4s.encode(claim, key, algo)\nJwtJson4s.encode(header, claim, key)","title":"Encoding"},{"location":"jwt-json4s.html#decoding","text":"copysource// You can decode to JsObject\nJwtJson4s.decodeJson(token, key, Seq(JwtAlgorithm.HS256))\nJwtJson4s.decodeJsonAll(token, key, Seq(JwtAlgorithm.HS256))\n// Or to case classes\nJwtJson4s.decode(token, key, Seq(JwtAlgorithm.HS256))\nJwtJson4s.decodeAll(token, key, Seq(JwtAlgorithm.HS256))","title":"Decoding"},{"location":"jwt-play-json.html","text":"","title":"Play Json"},{"location":"jwt-play-json.html#play-json","text":"API Documentation\nlibraryDependencies += \"com.github.jwt-scala\" %% \"jwt-play-json\" % \"11.0.3\"","title":"Play Json"},{"location":"jwt-play-json.html#basic-usage","text":"copysourceimport java.time.Clock\n\nimport pdi.jwt._\nimport play.api.libs.json.Json\n\nimplicit val clock: Clock = Clock.systemUTC\n\nval claim = Json.obj((\"user\", 1), (\"nbf\", 1431520421))\nval key = \"secretKey\"\nval algo = JwtAlgorithm.HS256\n\nJwtJson.encode(claim)\n\nval token = JwtJson.encode(claim, key, algo)\n\nJwtJson.decodeJson(token, key, Seq(JwtAlgorithm.HS256))\n\nJwtJson.decode(token, key, Seq(JwtAlgorithm.HS256))","title":"Basic usage"},{"location":"jwt-play-json.html#encoding","text":"copysourceval header = Json.obj((\"typ\", \"JWT\"), (\"alg\", \"HS256\"))\n// From just the claim to all possible attributes\nJwtJson.encode(claim)\nJwtJson.encode(claim, key, algo)\nJwtJson.encode(header, claim, key)","title":"Encoding"},{"location":"jwt-play-json.html#decoding","text":"copysource// You can decode to JsObject\nJwtJson.decodeJson(token, key, Seq(JwtAlgorithm.HS256))\nJwtJson.decodeJsonAll(token, key, Seq(JwtAlgorithm.HS256))\n// Or to case classes\nJwtJson.decode(token, key, Seq(JwtAlgorithm.HS256))\nJwtJson.decodeAll(token, key, Seq(JwtAlgorithm.HS256))","title":"Decoding"},{"location":"jwt-play-json.html#formating","text":"The project provides implicit reader and writer for both JwtHeader and JwtClaim\ncopysourceimport pdi.jwt.JwtJson._\n\n// Reads\nJson.fromJson[JwtHeader](header)\nJson.fromJson[JwtClaim](claim)\n\n// Writes\nJson.toJson(JwtHeader(JwtAlgorithm.HS256))\nJson.toJson(JwtClaim(\"\"\"{\"user\":1}\"\"\").issuedNow.expiresIn(10))\n// Or\nJwtHeader(JwtAlgorithm.HS256).toJsValue()\nJwtClaim(\"\"\"{\"user\":1}\"\"\").issuedNow.expiresIn(10).toJsValue()","title":"Formating"},{"location":"jwt-play-jwt-session.html","text":"","title":"JwtSession case class"},{"location":"jwt-play-jwt-session.html#jwtsession-case-class","text":"libraryDependencies += \"com.github.jwt-scala\" %% \"jwt-play\" % \"11.0.3\"\nProvides an API similar to the Play Session but using JsValue rather than String as values. It also separates headerData from claimData rather than having only one data.","title":"JwtSession case class"},{"location":"jwt-play-jwt-session.html#basic-usage","text":"copysource  import java.time.Clock\n\n  import pdi.jwt.JwtSession\n  import play.api.Configuration\n\n  implicit val clock: Clock = Clock.systemUTC\n\n//In a real Play! App this should normally be injected in the constructor with @Inject()\n  implicit val conf: Configuration = Configuration.reference\n\n// Let's create a session, it will automatically assign a default header. No\n// In your app, the default header would be generated from \"application.conf\" file\n// but here, it will just use the default values (which are all empty)\n  var session = JwtSession()\n\n// We can add a (key, value)\n  session = session + (\"user\", 1)\n\n// Or several of them\n  session = session ++ ((\"nbf\", 1431520421), (\"key\", \"value\"), (\"key2\", 2), (\"key3\", 3))\n\n// Also remove a key\n  session = session - \"key\"\n\n// Or several\n  session = session -- (\"key2\", \"key3\")\n\n// We can access a specific key\n  session.get(\"user\")\n\n// Test if the session is empty or not\n// (it is not here since we have several keys in the claimData)\n  session.isEmpty()\n\n// Serializing the session is the same as encoding it as a JSON Web Token\n  val token = session.serialize\n\n// You can create a JwtSession from a token of course\n  JwtSession.deserialize(token)\n\n// You could refresh the session to set its expiration in a few seconds from now\n// but you need to set \"session.maxAge\" in your \"application.conf\" and since this\n// is not a real Play application, we cannot do that, so here, the refresh will do nothing.\n  session = session.refresh()","title":"Basic usage"},{"location":"jwt-play-jwt-session.html#using-implicits","text":"If you have implicit Reads and/or Writes, you can access and/or add data directly as case class or object.\ncopysource// First, creating the implicits\n  import play.api.libs.json._\n\n  case class User(id: Long, name: String)\n  implicit val formatUser: Format[User] = Json.format[User]\n\n// Next, adding it to a new session\n  val session2 = JwtSession() + (\"user\", User(42, \"Paul\"))\n\n// Finally, accessing it\n  session2.getAs[User](\"user\")","title":"Using implicits"},{"location":"jwt-play-jwt-session.html#play-requestheader","text":"You can extract a JwtSession from a RequestHeader.\ncopysource  import pdi.jwt.JwtSession._\n  import play.api.Configuration\n  import play.api.test.FakeRequest\n\n// Default JwtSession\n  FakeRequest().jwtSession\n\n// What about some headers?\n// (the default header for a JSON Web Token is \"Authorization\" and it should be prefixed by \"Bearer \")\n  val request = FakeRequest().withHeaders((\"Authorization\", \"Bearer \" + session2.serialize))\n  request.jwtSession\n\n// It means you can directly read case classes from the session!\n// And that's pretty cool\n  request.jwtSession.getAs[User](\"user\")","title":"Play RequestHeader"},{"location":"jwt-play-jwt-session.html#play-result","text":"There are also implicit helpers around Result to help you manipulate the session inside it.\ncopysource  import play.api.mvc._\n  implicit val implRequest: FakeRequest[AnyContentAsEmpty.type] = request\n\n// Let's begin by creating a Result\n  var result: play.api.mvc.Result = play.api.mvc.Results.Ok\n\n// We can already get a JwtSession from our implicit RequestHeader\n  result.jwtSession\n\n// Setting a new empty JwtSession\n  result = result.withNewJwtSession\n\n// Or from an existing JwtSession\n  result = result.withJwtSession(session2)\n\n// Or from a JsObject\n  result = result.withJwtSession(Json.obj((\"id\", 1), (\"key\", \"value\")))\n\n// Or from (key, value)\n  result = result.withJwtSession((\"id\", 1), (\"key\", \"value\"))\n\n// We can add stuff to the current session (only (String, String))\n  result = result.addingToJwtSession((\"key2\", \"value2\"), (\"key3\", \"value3\"))\n\n// Or directly classes or objects if you have the correct implicit Writes\n  result = result.addingToJwtSession(\"user\", User(1, \"Paul\"))\n\n// Removing from session\n  result = result.removingFromJwtSession(\"key2\", \"key3\")\n\n// Refresh the current session\n  result = result.refreshJwtSession\n\n// So, at the end, you can do\n  result.jwtSession.getAs[User](\"user\")","title":"Play Result"},{"location":"jwt-play-jwt-session.html#play-configuration","text":"","title":"Play configuration"},{"location":"jwt-play-jwt-session.html#secret-key","text":"play.http.secret.key\nDefault: none\nThe secret key is used to secure cryptographics functions. We are using the same key to sign Json Web Tokens so you don’t need to worry about it.","title":"Secret key"},{"location":"jwt-play-jwt-session.html#private-key","text":"play.http.session.privateKey\nDefault: none\nThe PKCS8 format private key is used to sign JWT session. If play.http.session.privateKey is missing play.http.secret.key used instead.","title":"Private key"},{"location":"jwt-play-jwt-session.html#public-key","text":"play.http.session.publicKey\nDefault: none\nThe X.509 format public key is used to verify JWT session signed with private key play.http.session.privateKey","title":"Public key"},{"location":"jwt-play-jwt-session.html#session-timeout","text":"play.http.session.maxAge\nDefault: none\nJust like for the cookie session, you can use this key to specify the duration, in milliseconds or using the duration syntax (for example 30m or 1h), after which the user should be logout, which mean the token will no longer be valid. It means you need to refresh the expiration date at each request","title":"Session timeout"},{"location":"jwt-play-jwt-session.html#signature-algorithm","text":"play.http.session.algorithm\nDefault: HS256 Supported: HMD5, HS1, HS224, HS256, HS384, HS512, RS256, RS384, RS512, ES256, ES384, ES512\nYou can specify which algorithm you want to use, among the supported ones, in order to create the signature which will assure you that nobody can actually change the token. You should probably stick with the default one or use HmacSHA512 for maximum security.","title":"Signature algorithm"},{"location":"jwt-play-jwt-session.html#header-name","text":"play.http.session.jwtName\nDefault: Authorization\nYou can change the name of the header in which the token should be stored. It will be used for both requests and responses.","title":"Header name"},{"location":"jwt-play-jwt-session.html#response-header-name","text":"play.http.session.jwtResponseName\nDefault: none\nIf you need to have a different header for request and response, you can override the response header using this key.","title":"Response header name"},{"location":"jwt-play-jwt-session.html#token-prefix","text":"play.http.session.tokenPrefix\nDefault: “Bearer ”\nAuthorization header should have a prefix before the token, like “Basic” for example. For a JWT token, it should be “Bearer” (which is the default value) but you can freely change or remove it (using an empty string). The token prefix will be directly prepend before the token, so be sure to put any necessary whitespaces in it.","title":"Token prefix"},{"location":"jwt-upickle.html","text":"","title":"upickle"},{"location":"jwt-upickle.html#upickle","text":"API Documentation\nlibraryDependencies += \"com.github.jwt-scala\" %% \"jwt-upickle\" % \"11.0.3\"","title":"upickle"},{"location":"jwt-upickle.html#basic-usage","text":"copysourceimport java.time.Instant\n\nimport pdi.jwt.{JwtAlgorithm, JwtClaim, JwtUpickle}\n\nval claim = JwtClaim(\n  expiration = Some(Instant.now.plusSeconds(157784760).getEpochSecond),\n  issuedAt = Some(Instant.now.getEpochSecond)\n)\nval key = \"secretKey\"\nval algo = JwtAlgorithm.HS256\n\nval token = JwtUpickle.encode(claim, key, algo)\n\nJwtUpickle.decodeJson(token, key, Seq(JwtAlgorithm.HS256))\nJwtUpickle.decode(token, key, Seq(JwtAlgorithm.HS256))","title":"Basic usage"},{"location":"jwt-upickle.html#encoding","text":"copysource}\n\n@nowarn\nobject UpickleEncode {\n  import java.time.Instant\n\n  import pdi.jwt.{JwtAlgorithm, JwtUpickle}\n  import upickle.default._\n\n  val key = \"secretKey\"\n  val algo = JwtAlgorithm.HS256\n\n  val claimJson = read[ujson.Value](s\"\"\"{\"expires\":${Instant.now.getEpochSecond}}\"\"\")\n  val header = read[ujson.Value](\"\"\"{\"typ\":\"JWT\",\"alg\":\"HS256\"}\"\"\")\n  // From just the claim to all possible attributes\n  JwtUpickle.encode(claimJson)\n  JwtUpickle.encode(claimJson, key, algo)\n  JwtUpickle.encode(header, claimJson, key)","title":"Encoding"},{"location":"jwt-upickle.html#decoding","text":"copysourceimport java.time.Instant\n\nimport pdi.jwt.{JwtAlgorithm, JwtClaim, JwtUpickle}\n\nval claim = JwtClaim(\n  expiration = Some(Instant.now.plusSeconds(157784760).getEpochSecond),\n  issuedAt = Some(Instant.now.getEpochSecond)\n)\nval key = \"secretKey\"\nval algo = JwtAlgorithm.HS256\n\nval token = JwtUpickle.encode(claim, key, algo)\n\n// You can decode to JsObject\nJwtUpickle.decodeJson(token, key, Seq(JwtAlgorithm.HS256))\nJwtUpickle.decodeJsonAll(token, key, Seq(JwtAlgorithm.HS256))\n// Or to case classes\nJwtUpickle.decode(token, key, Seq(JwtAlgorithm.HS256))\nJwtUpickle.decodeAll(token, key, Seq(JwtAlgorithm.HS256))","title":"Decoding"},{"location":"jwt-zio-json.html","text":"","title":"ZIO Json"},{"location":"jwt-zio-json.html#zio-json","text":"API Documentation\nlibraryDependencies += \"com.github.jwt-scala\" %% \"jwt-zio-json\" % \"11.0.3\"","title":"ZIO Json"},{"location":"jwt-zio-json.html#basic-usage","text":"copysourceimport java.time.Instant\n\nimport pdi.jwt.{JwtAlgorithm, JwtClaim, JwtZIOJson}\n\nval claim = JwtClaim(\n  expiration = Some(Instant.now.plusSeconds(157784760).getEpochSecond),\n  issuedAt = Some(Instant.now.getEpochSecond)\n)\nval key = \"secretKey\"\nval algo = JwtAlgorithm.HS256\n\nval token = JwtZIOJson.encode(claim, key, algo)\n\nJwtZIOJson.decodeJson(token, key, Seq(JwtAlgorithm.HS256))\nJwtZIOJson.decode(token, key, Seq(JwtAlgorithm.HS256))","title":"Basic usage"},{"location":"jwt-zio-json.html#encoding","text":"copysource  import java.time.Instant\n\n  import pdi.jwt.{JwtAlgorithm, JwtZIOJson}\n  import zio.json._\n  import zio.json.ast._\n\n  val key = \"secretKey\"\n  val algo = JwtAlgorithm.HS256\n\n  val claimJsonEither = s\"\"\"{\"expires\":${Instant.now.getEpochSecond}}\"\"\".fromJson[Json]\n  val headerEither = \"\"\"{\"typ\":\"JWT\",\"alg\":\"HS256\"}\"\"\".fromJson[Json]\n// From just the claim to all possible attributes\n  for {\n    claimJson <- claimJsonEither\n    header <- headerEither\n  } yield {\n    JwtZIOJson.encode(claimJson)\n    JwtZIOJson.encode(claimJson, key, algo)\n    JwtZIOJson.encode(header, claimJson, key)\n  }","title":"Encoding"},{"location":"jwt-zio-json.html#decoding","text":"copysource  import java.time.Instant\n\n  import pdi.jwt.{JwtAlgorithm, JwtClaim, JwtZIOJson}\n\n  val claim = JwtClaim(\n    expiration = Some(Instant.now.plusSeconds(157784760).getEpochSecond),\n    issuedAt = Some(Instant.now.getEpochSecond)\n  )\n  val key = \"secretKey\"\n  val algo = JwtAlgorithm.HS256\n\n  val token = JwtZIOJson.encode(claim, key, algo)\n\n// You can decode to JsObject\n  JwtZIOJson.decodeJson(token, key, Seq(JwtAlgorithm.HS256))\n  JwtZIOJson.decodeJsonAll(token, key, Seq(JwtAlgorithm.HS256))\n// Or to case classes\n  JwtZIOJson.decode(token, key, Seq(JwtAlgorithm.HS256))\n  JwtZIOJson.decodeAll(token, key, Seq(JwtAlgorithm.HS256))","title":"Decoding"}]}